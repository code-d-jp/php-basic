# ファイルシステムを扱う関数

ここではファイルシステムを扱う関数について見ていきましょう。以下の関数を取り上げます。

+ file_put_contents — 文字列をファイルに書き込む
+ file_get_contents — ファイルの内容を全て文字列に読み込む
+ file — ファイル全体を読み込んで配列に格納する
+ mkdir — ディレクトリを作る
+ fopen — ファイルまたは URL をオープンする
+ fclose — オープンされたファイルポインタをクローズする
+ fgets — ファイルポインタから 1 行取得す
+ fwrite — バイナリセーフなファイル書き込み処理

> 配列を扱う関数の詳細については[PHP マニュアル 関数リファレンス 変数・データ型関連 配列](http://php.net/manual/ja/book.array.php)を参照してください。

### テキストファイルについて

本章で取り上げるファイルシステムを扱う関数のほとんどは、テキストファイルを対象に扱うものです。テキストファイルとはアルファベットや数字、日本語のようなテキストデータで構成されているファイルのことです。そのためJPEGやPNGのような画像データや音声データ、動画データのようなファイルはここで紹介する関数で扱うことはできないので注意してください。

また本章ではテキストファイルを.txtという拡張子で表現します。他にもHTMLファイルやJSONファイル、CSVファイルなどもテキストファイルですのでここで紹介する関数で処理することができます。

## file_put_contents — 文字列をファイルに書き込む

`file_put_contents`関数は文字列をファイルに書き込む関数です。テキストエディタを開いて次のプログラム（fs1.php）を作成してみましょう。

```
<?php
$str = "Hello World" . PHP_EOL;
$file = "hello.txt";
file_put_contents($file, $str);
```

`file_put_contents`関数は引数を2つ指定します。

+ 第1引数
  + ファイル名
+ 第2引数
  + ファイルに書き込む文字列

さきほどのプログラムの場合は`file_put_contents`関数の第1引数に`$file`、第2引数に`$str`を指定しています。この場合、`file_put_contents`関数は変数`$str`の内容を`$file`で指定されたファイルに書き込みます。

> `file_put_contents`関数は戻り値に書き込んだデータのバイト数を返却します。ここでは戻り値を利用していません。

作成したプログラムを実行してみましょう。ターミナルから次のように実行します。

```
$ php fs1.php
```

上記のように実行してもターミナル上には何も表示されないでしょう。その代わりカレントフォルダ上に"hello.txt"というファイルが生成されているのがわかるでしょう。

ターミナルでlsコマンドやcatコマンドで確認してみましょう。

```
$ ls hello.txt
hello.txt
$ cat hello.txt
Hello World
```

> lsコマンドはカレントフォルダに存在するファイルやフォルダを表示するコマンドです。catコマンドはファイルの中身を出力するコマンドです。Windowsの場合はコマンドプロンプト上でdirコマンドやtypeコマンドを使います。

上記の実行結果からカレントフォルダ上に`"hello.txt"`というファイルが作成されており、`hello.txt`の中には`Hello World`と書き込まれているのがわかります。

> hello.txtファイルはエディタで開いて確認しても構いません。

### 上書きモードと追記モード

`file_put_contents`関数はデフォルトで上書きモードでファイルに書き込みを行います。先ほどのプログラム（fs1.php）を次のように修正してみましょう。

```
<?php
$str = "Hello PHP" . PHP_EOL;
$file = "hello.txt";
file_put_contents($file, $str);
```

> ファイルに書き込む内容を`"Hello World"`から`"Hello PHP"`に変更しています。

再度プログラムを実行してファイルの内容をcatコマンドで表示してみましょう。

```
$ php fs1.php
$ cat hello.txt
Hello PHP
```

`hello.txt`の内容は上書きされて`Hello PHP`に置き換わっているのがわかります。もし上書きするのではなく、ファイルの末尾にデータを追加するのであればfile_put_contents関数の第3引数に定数FILE_APPENDを指定します。先ほどのプログラム（fs1.php）を次のように修正してみましょう。

```
<?php
$str = "Hello Programming" . PHP_EOL;
$file = "hello.txt";
file_put_contents($file, $str, FILE_APPEND);
```

再度プログラムを実行してファイルの内容をcatコマンドで表示してみましょう。

```
$ php fs1.php
$ cat hello.txt
Hello PHP
Hello Programming
```

実行結果から追記モードでファイルに書き込みを行っている様子がわかります。


## file_get_contents — ファイルの内容を全て文字列に読み込む

`file_get_contents`関数はファイルの内容を読み込む関数です。次のプログラム（fs2.php）を作成してみましょう。

```
<?php
$file = "hello.txt";
$str = file_get_contents($file);
echo $str;
```

`file_get_contents`関数は引数に、読み込み対象となるファイル名を指定します。上記の場合は`$file`を引数に指定しているので、`$file`に代入されているデータである`"hello.txt"`という名前のファイルを読み込み、ファイルの内容を戻り値として返却します。また戻り値を受け取るために`$str`変数を用意しています。

> ここではhello.txtファイルに以下の内容が保存されているものとします。
Hello PHP
Hello Programming

作成したプログラムを実行してみましょう。ターミナルから次のように実行します。

```
❯ php fs2.php
Hello PHP
Hello Programming
```

実行結果から`"hello.txt"`ファイルの内容を読み込んで処理できているのがわかります。

## file — ファイル全体を読み込んで配列に格納する


`file`関数はファイルの内容を読み込んで配列に変換する関数です。次のプログラム（fs3.php）を作成してみましょう。

```
<?php
$file = "hello.txt";
$array = file($file);
print_r($array);
```

`file`関数は引数に、読み込み対象となるファイル名を指定します。上記の場合は`$file`を引数に指定しているので、`$file`に代入されているデータである`"hello.txt"`という名前のファイルを読み込み、ファイルの内容を行単位で配列の要素に変換し、戻り値として返却します。またここでは戻り値を受け取るために`$array`変数を用意しています。

作成したプログラムを実行してみましょう。ターミナルから次のように実行します。

```
$ php fs3.php
Array
(
    [0] => Hello PHP

    [1] => Hello Programming

)
```

実行結果から`"hello.txt"`ファイルの内容を読み込んで、行単位で配列の要素に変換しているのがわかります。

ところで先ほどの出力結果をじっくりみると改行が多いのが気になります。これは配列の各要素には改行コードが残っているためです。もし、改行コードが含まれない場合は次のような実行結果になるはずです。

```
$ php fs3.php
Array
(
    [0] => Hello PHP
    [1] => Hello Programming
)
```

`file`関数はファイルの内容を行単位で配列の要素に変換しますが、このとき各行の終端の改行コードの取扱については注意が必要です。`file`関数は第2引数に定数`FILE_IGNORE_NEW_LINES`を指定することで行の末端の改行コードを取り除くことができます。さきほどのプログラム（fs3.php）を次のように修正してみましょう。

```
<?php
$file = "hello.txt";
$array = file($file, FILE_IGNORE_NEW_LINES);
print_r($array);
```

file関数の第2引数に定数`FILE_IGNORE_NEW_LINES`を指定しています。修正したプログラムを実行してみましょう。ターミナルから次のように実行します。

```
$ php fs3.php
Array
(
    [0] => Hello PHP
    [1] => Hello Programming
)
```

実行結果から各業の末端の改行コードが除去されているのがわかります。

> PHPの関数には、引数として定数の指定が可能なものも多くあります。どのような定数が使えるのか調べるには[PHPマニュアル 関数リファレンス](http://php.net/manual/ja/funcref.php)を参照するようにします。


## mkdir — ディレクトリを作る

`mkdir`関数はフォルダ（ディレクトリ）を作成する関数です。次のプログラム（fs4.php）を作成してみましょう。

```
<?php
$dir = "hello";
mkdir($dir);
```

`mkdir`関数は引数に、フォルダ名を指定します。上記の場合は`$dir`を引数に指定しているので、`$dir`に代入されているデータである`"hello"`という名前のフォルダを作成します。戻り値として返却します。

> mkdir関数は戻り値として論理型データ（`true` or `false`）を返します。フォルダの作成に成功した場合は`true`失敗した場合は`false`を返します。ここでは戻り値を利用していせんので注意してください。

作成したプログラムを実行してみましょう。ターミナルから次のように実行します。

```
$ php fs4.php
```

上記のように実行してもターミナル上には何も表示されないでしょう。その代わりカレントフォルダ上に`hello`という名前のフォルダが生成されているのがわかるでしょう。

ターミナルでlsコマンドで確認してみましょう。

```
$ ls -l | grep hello
drwxr-xr-x  2 murayama  staff   64  3  7 16:57 hello/
-rw-r--r--  1 murayama  staff   28  3  7 16:18 hello.txt
```

上記のようにすれば`hello/`という名前のフォルダを確認できるでしょう。

## ファイルの読み込み

これまでに`file_put_contents`関数や`file`関数によるファイルの読み込みについて見てきました。ファイルの内容を1つの文字列データとして読み込むのであれば`file_put_contents`関数、行単位で配列に変換したいのであれば`file`関数を使うことができます。

これらの関数は手軽に使えますが、ファイルサイズが大きい場合はその分メモリを消費してしまうことになるので注意が必要です。

> プログラムの実行環境に依存しますが、ファイルサイズが数KB程度であれば`file_put_contents`関数や`file`関数を使っても問題ないかもしれません。

読み込むファイルサイズが大きい場合や、ファイルの入出力を細かく制御したい場合は`fopen`関数や`fwrite`関数などを組み合わせて制御します。ここでは以下の関数を扱うプログラムを取り上げます。

+ fopen — ファイルまたは URL をオープンする
+ fgets — ファイルポインタから 1 行取得す
+ fclose — オープンされたファイルポインタをクローズする

次のプログラム（fs5.php）を作成してみましょう。

```
<?php
$file = "hello.txt";
$handle = fopen($file, "r");

$line = fgets($handle);
echo $line;

fclose($handle);
```

またここではカレントフォルダ上に以下のようなhello.txtファイルが存在するものとします。

```
Hello PHP
Hello Programming
```

まずはプログラムを実行してみましょう。

```
$ php fs5.php
Hello PHP
```

実行結果からhello.txtファイルの1行目の内容が出力されているのがわかります。

それではプログラムの詳細を見てみましょう。ファイルの読み込みを行うには、始めにfopen関数を使います。

```
$file = "hello.txt"
$handle = fopen($file, "r");
```

fopen関数は第1引数に対象となるファイル名、第2引数にアクセス形式を指定します。アクセス形式の主要なものは以下のとおりです。

+ "r"
  + 読み込みモード
+ "w"
  + 書き込みモード（上書き）
+ "a"
  + 書き込みモード（追記）

ここでは`"r"`を指定しているので、ファイルの内容を読み込む目的でファイルを開いています。

また`fopen`関数は戻り値として、ファイルポインタを返却します。ファイルポインタとはファイルとの接続を表すものです。これまでのように文字列や数値のようなデータではありませんが、後の`fgets`関数や`fclose`関数の引数として渡すことでファイルとやりとりすることができます。

> ファイルポインタはファイルポインタリソースと呼ぶこともあります。

次に`fgets`関数を呼び出しています。

```
$line = fgets($handle);
echo $line;
```

`fgets`関数は引数で受け取ったファイルポインタリソースからデータを1行読み取り、戻り値として返却します。

最後に`flose`関数を呼び出しています。

```
fclose($handle);
```

`fclose`関数は開いているファイルを閉じるための関数です。`fclose`関数は引数にファイルポインタリソースを受け取ります。コンピュータ上で開けるファイルの数には上限があるので、作業を終えたファイルは閉じておく必要があります。

> PHPプログラムの停止時に、プログラム内で開いていたファイルは自動的に閉じるようになっています。

さきほどのプログラム（fs5.php）は以下のようにwhile文を使うように修正することで、ファイル内のすべての内容を出力することができます。

```
<?php
$file = "hello.txt";
$handle = fopen($file, "r");
while(($line = fgets($handle)) !== false) {
  echo $line;
}
fclose($handle);
```

`fgets`関数はファイルから1行ずつデータを読み込み、戻り値として返却します。`fgets`関数を繰り返し呼ぶことでファイルの行を順に処理していくことができます。`fgets`関数はファイルの終端に達すると`false`を戻り値として返します。

上記のプログラムでは`while`文の条件の中で`($line = fgets($handle))`とすることでファイルポインタから1行のデータを読み込みます。ファイルの終端に達している場合は`false`が返却されるため上記のように実装することができます。

それではプログラムを実行してみましょう。

```
$ php fs5_2.php
Hello PHP
Hello Programming
```

実行結果からファイルの内容を全て出力できているのがわかります。

## ファイルの書き込み

ファイルの書き込みも`fopen`関数、`fwrite`関数、`fclose`関数によって制御できます。

+ fopen — ファイルまたは URL をオープンする
+ fwrite — バイナリセーフなファイル書き込み処理
+ fclose — オープンされたファイルポインタをクローズする

次のプログラム（fs6.php）を作成してみましょう。

```
<?php
$names = ["Andy", "Betty", "Carol"];
$file = "names.txt";
$handle = fopen($file, "w");
foreach($names as $name) {
  fwrite($handle, $name . PHP_EOL);
}
fclose($handle);
```

まずはプログラムを実行してみましょう。

```
$ php fs6.php
```

上記のように実行してもターミナル上には何も表示されないでしょう。その代わりカレントフォルダ上に"names.txt"というファイルが生成されているのがわかるでしょう。

ターミナルでlsコマンドやcatコマンドで確認してみましょう。

```
$ ls names.txt
names.txt
$ cat names.txt
Andy
Betty
Carol
```

それではプログラムの詳細を見てみましょう。このプログラムでは配列`$names`に代入されている3人の名前をファイルに書き込むプログラムです。`fopen`関数でファイルを開いていますがアクセス形式に"w"を指定しています。

```
$handle = fopen($file, "w");
```

アクセス形式"w"は上書きモードでファイルに書き込みを行います。

> "a"を指定すると追記モードになります。

その後、`foreach`文の中で`fwrite`関数を使ってファイルにデータを書き込んでいます。

```
foreach($names as $name) {
  fwrite($handle, $name . PHP_EOL);
}
```

`fwrite`関数は第1引数にファイルポインタ、第2引数にファイルに書き込むデータを指定します。

`foreach`文の繰り返し処理を終えた後は`fclose`関数でファイルを閉じています。

## ファイルの読み込み（書き込み）に失敗する場合

ファイルシステム関数は、文字列を扱う関数や配列を扱う関数と異なり、プログラムの実行環境の影響を受けます。たとえば冒頭で取り上げたプログラム（fs1.php）をもう一度見てみましょう。

```
<?php
$str = "Hello World" . PHP_EOL;
$file = "hello.txt";
file_put_contents($file, $str);
```

このプログラムは正しく動作するように見えますが、以下のようなケースではエラーとなってしまいます。

+ 他のプログラムがファイルを処理（ロック）の場合
+ ファイルの書き込み権限がない場合
+ ディスク容量が足りない場合

上記のようなケースはプログラムの作り方に不具合があるのではなく、プログラムの動作する環境側の問題と言えます。

> このような問題はファイルシステムのやりとり以外でも、ネットワークやデータベースにアクセスする場合にも考えないといけません。

そのためここで紹介したファイルシステムを扱う関数のほとんどは、実行時にエラーが発生した場合は戻り値に関数の戻り値に`false`を返す仕組みになっています。

たとえば先ほどのプログラム（fs1.php）の場合、以下のように`file_put_contents`関数の戻り値を判定することでファイルの書き込未失敗を検出することができます。

```
<?php
$str = "Hello World" . PHP_EOL;
$file = "hello.txt";
$result = file_put_contents($file, $str);
if ($resutl === false) {
  echo "error" . PHP_EOL;
}
```

`file_put_contents`関数は、正常にファイルに書き込めた場合は、書き込んだデータのバイト数を戻り値で返しますが、ファイルの書き込みに失敗した場合は`false`を返却するようになっています。上記のように戻り値を`if`文で確認することで、ファイル書き込みに失敗した場合の後処理を実装することができます。


もう一つ例を見ておきましょう。先に取り上げたファイルを読み込むプログラム（fs5.php）を見てみましょう。

```
$file = "hello.txt";
$handle = fopen($file, "r");
while(($line = fgets($handle)) !== false) {
  echo $line;
}
fclose($handle);
```

`fopen`関数で読み込み対象のファイル名hello.txtを指定していますが、実行環境によってはhello.txtファイルが存在しない可能性も考えられます。`fopen`関数は、通常戻り値としてファイルポインタを返しますが、読み込み対象のファイルが存在しない場合やアクセス権限が不足する場合などは戻り値に`false`を返します。そのため以下のように実装することでファイル読み込みの失敗を検出することができます。

```
<?php
$file = "hello.txt";
$handle = fopen($file, "r");
if ($handle === false) {
  die("can't open file");
}
while(($line = fgets($handle)) !== false) {
  echo $line;
}
fclose($handle);
```

上記のプログラムでは`$handle`変数が`false`の場合には`die`関数を使って処理を異常終了させています。PHPのプログラムは`die`関数を呼び出すとその場でメッセージを出力して処理を終えるようになっています。ここではファイルのオープンに失敗した場合は後続の処理を実行せずに停止するようにしています。

